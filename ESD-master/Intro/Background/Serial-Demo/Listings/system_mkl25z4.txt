; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\system_mkl25z4.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\system_mkl25z4.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I.\inc -I"C:\Users\Alex\Documents\Teaching\ECE492 - ESA\Code\git\ESA\MCU_Intro_UV5\Serial-Demo\RTE" -I"C:\Users\Alex\Documents\Teaching\ECE492 - ESA\Code\git\ESA\MCU_Intro_UV5\Serial-Demo\RTE\Device\MKL25Z128xxx4" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0-Beta4\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.12.0\Device\Include -D__UVISION_VERSION=517 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\system_mkl25z4.crf RTE\Device\MKL25Z128xxx4\system_MKL25Z4.c]
                          THUMB

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;276    
;;;277    void SystemCoreClockUpdate (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;278      uint32_t MCGOUTClock;                /* Variable to store output clock frequency of the MCG module */
;;;279      uint16_t Divider;
;;;280    
;;;281      if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x00U) {
000002  485c              LDR      r0,|L1.372|
000004  7800              LDRB     r0,[r0,#0]
000006  21c0              MOVS     r1,#0xc0
000008  4008              ANDS     r0,r0,r1
00000a  2800              CMP      r0,#0
00000c  d17e              BNE      |L1.268|
;;;282        /* Output of FLL or PLL is selected */
;;;283        if ((MCG->C6 & MCG_C6_PLLS_MASK) == 0x00U) {
00000e  4859              LDR      r0,|L1.372|
000010  7940              LDRB     r0,[r0,#5]
000012  2140              MOVS     r1,#0x40
000014  4008              ANDS     r0,r0,r1
000016  2800              CMP      r0,#0
000018  d165              BNE      |L1.230|
;;;284          /* FLL is selected */
;;;285          if ((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U) {
00001a  4856              LDR      r0,|L1.372|
00001c  7800              LDRB     r0,[r0,#0]
00001e  2104              MOVS     r1,#4
000020  4008              ANDS     r0,r0,r1
000022  2800              CMP      r0,#0
000024  d12c              BNE      |L1.128|
;;;286            /* External reference clock is selected */
;;;287            MCGOUTClock = CPU_XTAL_CLK_HZ; /* System oscillator drives MCG clock */
000026  4c54              LDR      r4,|L1.376|
;;;288            if ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x00U) {
000028  4852              LDR      r0,|L1.372|
00002a  7840              LDRB     r0,[r0,#1]
00002c  2130              MOVS     r1,#0x30
00002e  4008              ANDS     r0,r0,r1
000030  2800              CMP      r0,#0
000032  d017              BEQ      |L1.100|
;;;289              switch (MCG->C1 & MCG_C1_FRDIV_MASK) {
000034  484f              LDR      r0,|L1.372|
000036  7800              LDRB     r0,[r0,#0]
000038  2138              MOVS     r1,#0x38
00003a  4008              ANDS     r0,r0,r1
00003c  2830              CMP      r0,#0x30
00003e  d004              BEQ      |L1.74|
000040  2838              CMP      r0,#0x38
000042  d105              BNE      |L1.80|
;;;290              case 0x38U:
;;;291                Divider = 1536U;
000044  2503              MOVS     r5,#3
000046  026d              LSLS     r5,r5,#9
;;;292                break;
000048  e00b              B        |L1.98|
                  |L1.74|
;;;293              case 0x30U:
;;;294                Divider = 1280U;
00004a  2505              MOVS     r5,#5
00004c  022d              LSLS     r5,r5,#8
;;;295                break;
00004e  e008              B        |L1.98|
                  |L1.80|
;;;296              default:
;;;297                Divider = (uint16_t)(32LU << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
000050  4848              LDR      r0,|L1.372|
000052  7800              LDRB     r0,[r0,#0]
000054  2138              MOVS     r1,#0x38
000056  4008              ANDS     r0,r0,r1
000058  08c1              LSRS     r1,r0,#3
00005a  2020              MOVS     r0,#0x20
00005c  4088              LSLS     r0,r0,r1
00005e  b285              UXTH     r5,r0
;;;298                break;
000060  bf00              NOP      
                  |L1.98|
000062  e007              B        |L1.116|
                  |L1.100|
;;;299              }
;;;300            } else {/* ((MCG->C2 & MCG_C2_RANGE_MASK) != 0x00U) */
;;;301              Divider = (uint16_t)(1LU << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
000064  4843              LDR      r0,|L1.372|
000066  7800              LDRB     r0,[r0,#0]
000068  2138              MOVS     r1,#0x38
00006a  4008              ANDS     r0,r0,r1
00006c  08c1              LSRS     r1,r0,#3
00006e  2001              MOVS     r0,#1
000070  4088              LSLS     r0,r0,r1
000072  b285              UXTH     r5,r0
                  |L1.116|
;;;302            }
;;;303            MCGOUTClock = (MCGOUTClock / Divider); /* Calculate the divided FLL reference clock */
000074  4629              MOV      r1,r5
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       __aeabi_uidivmod
00007c  4604              MOV      r4,r0
00007e  e001              B        |L1.132|
                  |L1.128|
;;;304          } else { /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)) */
;;;305            MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* The slow internal reference clock is selected */
000080  2401              MOVS     r4,#1
000082  03e4              LSLS     r4,r4,#15
                  |L1.132|
;;;306          } /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)) */
;;;307          /* Select correct multiplier to calculate the MCG output clock  */
;;;308          switch (MCG->C4 & (MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) {
000084  483b              LDR      r0,|L1.372|
000086  78c0              LDRB     r0,[r0,#3]
000088  21e0              MOVS     r1,#0xe0
00008a  4008              ANDS     r0,r0,r1
00008c  06c1              LSLS     r1,r0,#27
00008e  0ec9              LSRS     r1,r1,#27
000090  2900              CMP      r1,#0
000092  d126              BNE      |L1.226|
000094  1140              ASRS     r0,r0,#5
000096  0003              MOVS     r3,r0
000098  f7fffffe          BL       __ARM_common_switch8
00009c  0805090d          DCB      0x08,0x05,0x09,0x0d
0000a0  1115191d          DCB      0x11,0x15,0x19,0x1d
0000a4  2023              DCB      0x20,0x23
;;;309            case 0x00U:
;;;310              MCGOUTClock *= 640U;
0000a6  2005              MOVS     r0,#5
0000a8  01c0              LSLS     r0,r0,#7
0000aa  4344              MULS     r4,r0,r4
;;;311              break;
0000ac  e01a              B        |L1.228|
;;;312            case 0x20U:
;;;313              MCGOUTClock *= 1280U;
0000ae  2005              MOVS     r0,#5
0000b0  0200              LSLS     r0,r0,#8
0000b2  4344              MULS     r4,r0,r4
;;;314              break;
0000b4  e016              B        |L1.228|
;;;315            case 0x40U:
;;;316              MCGOUTClock *= 1920U;
0000b6  200f              MOVS     r0,#0xf
0000b8  01c0              LSLS     r0,r0,#7
0000ba  4344              MULS     r4,r0,r4
;;;317              break;
0000bc  e012              B        |L1.228|
;;;318            case 0x60U:
;;;319              MCGOUTClock *= 2560U;
0000be  2005              MOVS     r0,#5
0000c0  0240              LSLS     r0,r0,#9
0000c2  4344              MULS     r4,r0,r4
;;;320              break;
0000c4  e00e              B        |L1.228|
;;;321            case 0x80U:
;;;322              MCGOUTClock *= 732U;
0000c6  20b7              MOVS     r0,#0xb7
0000c8  0080              LSLS     r0,r0,#2
0000ca  4344              MULS     r4,r0,r4
;;;323              break;
0000cc  e00a              B        |L1.228|
;;;324            case 0xA0U:
;;;325              MCGOUTClock *= 1464U;
0000ce  20b7              MOVS     r0,#0xb7
0000d0  00c0              LSLS     r0,r0,#3
0000d2  4344              MULS     r4,r0,r4
;;;326              break;
0000d4  e006              B        |L1.228|
;;;327            case 0xC0U:
;;;328              MCGOUTClock *= 2197U;
0000d6  4829              LDR      r0,|L1.380|
0000d8  4344              MULS     r4,r0,r4
;;;329              break;
0000da  e003              B        |L1.228|
;;;330            case 0xE0U:
;;;331              MCGOUTClock *= 2929U;
0000dc  4828              LDR      r0,|L1.384|
0000de  4344              MULS     r4,r0,r4
;;;332              break;
0000e0  e000              B        |L1.228|
                  |L1.226|
;;;333            default:
;;;334              break;
0000e2  bf00              NOP      
                  |L1.228|
0000e4  e03b              B        |L1.350|
                  |L1.230|
;;;335          }
;;;336        } else { /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x00U)) */
;;;337          /* PLL is selected */
;;;338          Divider = (((uint16_t)MCG->C5 & MCG_C5_PRDIV0_MASK) + 0x01U);
0000e6  4823              LDR      r0,|L1.372|
0000e8  7900              LDRB     r0,[r0,#4]
0000ea  06c0              LSLS     r0,r0,#27
0000ec  0ec0              LSRS     r0,r0,#27
0000ee  1c45              ADDS     r5,r0,#1
;;;339          MCGOUTClock = (uint32_t)(CPU_XTAL_CLK_HZ / Divider); /* Calculate the PLL reference clock */
0000f0  4629              MOV      r1,r5
0000f2  4821              LDR      r0,|L1.376|
0000f4  f7fffffe          BL       __aeabi_uidivmod
0000f8  4604              MOV      r4,r0
;;;340          Divider = (((uint16_t)MCG->C6 & MCG_C6_VDIV0_MASK) + 24U);
0000fa  481e              LDR      r0,|L1.372|
0000fc  7940              LDRB     r0,[r0,#5]
0000fe  06c0              LSLS     r0,r0,#27
000100  0ec0              LSRS     r0,r0,#27
000102  4605              MOV      r5,r0
000104  3518              ADDS     r5,r5,#0x18
;;;341          MCGOUTClock *= Divider;          /* Calculate the MCG output clock */
000106  4620              MOV      r0,r4
000108  4368              MULS     r0,r5,r0
00010a  e000              B        |L1.270|
                  |L1.268|
00010c  e001              B        |L1.274|
                  |L1.270|
00010e  4604              MOV      r4,r0
000110  e025              B        |L1.350|
                  |L1.274|
;;;342        } /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x00U)) */
;;;343      } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x40U) {
000112  4818              LDR      r0,|L1.372|
000114  7800              LDRB     r0,[r0,#0]
000116  21c0              MOVS     r1,#0xc0
000118  4008              ANDS     r0,r0,r1
00011a  2840              CMP      r0,#0x40
00011c  d116              BNE      |L1.332|
;;;344        /* Internal reference clock is selected */
;;;345        if ((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U) {
00011e  4815              LDR      r0,|L1.372|
000120  7840              LDRB     r0,[r0,#1]
000122  07c0              LSLS     r0,r0,#31
000124  0fc0              LSRS     r0,r0,#31
000126  2800              CMP      r0,#0
000128  d102              BNE      |L1.304|
;;;346          MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* Slow internal reference clock selected */
00012a  2401              MOVS     r4,#1
00012c  03e4              LSLS     r4,r4,#15
00012e  e016              B        |L1.350|
                  |L1.304|
;;;347        } else { /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)) */
;;;348          Divider = (uint16_t)(0x01LU << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));
000130  4810              LDR      r0,|L1.372|
000132  7a00              LDRB     r0,[r0,#8]
000134  210e              MOVS     r1,#0xe
000136  4008              ANDS     r0,r0,r1
000138  0841              LSRS     r1,r0,#1
00013a  2001              MOVS     r0,#1
00013c  4088              LSLS     r0,r0,r1
00013e  b285              UXTH     r5,r0
;;;349          MCGOUTClock = (uint32_t) (CPU_INT_FAST_CLK_HZ / Divider); /* Fast internal reference clock selected */
000140  4629              MOV      r1,r5
000142  4810              LDR      r0,|L1.388|
000144  f7fffffe          BL       __aeabi_uidivmod
000148  4604              MOV      r4,r0
00014a  e008              B        |L1.350|
                  |L1.332|
;;;350        } /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)) */
;;;351      } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U) {
00014c  4809              LDR      r0,|L1.372|
00014e  7800              LDRB     r0,[r0,#0]
000150  21c0              MOVS     r1,#0xc0
000152  4008              ANDS     r0,r0,r1
000154  2880              CMP      r0,#0x80
000156  d101              BNE      |L1.348|
;;;352        /* External reference clock is selected */
;;;353        MCGOUTClock = CPU_XTAL_CLK_HZ;     /* System oscillator drives MCG clock */
000158  4c07              LDR      r4,|L1.376|
00015a  e000              B        |L1.350|
                  |L1.348|
;;;354      } else { /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U)) */
;;;355        /* Reserved value */
;;;356        return;
;;;357      } /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U)) */
;;;358      SystemCoreClock = (MCGOUTClock / (0x01U + ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)));
;;;359    }
00015c  bd70              POP      {r4-r6,pc}
                  |L1.350|
00015e  480a              LDR      r0,|L1.392|
000160  6840              LDR      r0,[r0,#4]            ;358
000162  0f00              LSRS     r0,r0,#28             ;358
000164  1c41              ADDS     r1,r0,#1              ;358
000166  4620              MOV      r0,r4                 ;358
000168  f7fffffe          BL       __aeabi_uidivmod
00016c  4907              LDR      r1,|L1.396|
00016e  6008              STR      r0,[r1,#0]            ;358  ; SystemCoreClock
000170  bf00              NOP      
000172  e7f3              B        |L1.348|
                          ENDP

                  |L1.372|
                          DCD      0x40064000
                  |L1.376|
                          DCD      0x007a1200
                  |L1.380|
                          DCD      0x00000895
                  |L1.384|
                          DCD      0x00000b71
                  |L1.388|
                          DCD      0x003d0900
                  |L1.392|
                          DCD      0x40048040
                  |L1.396|
                          DCD      SystemCoreClock

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;113    
;;;114    void SystemInit (void) {
000000  2000              MOVS     r0,#0
;;;115    #if (DISABLE_WDOG)
;;;116      /* SIM_COPC: COPT=0,COPCLKS=0,COPW=0 */
;;;117      SIM->COPC = (uint32_t)0x00u;
000002  4942              LDR      r1,|L2.268|
000004  6008              STR      r0,[r1,#0]
;;;118    #endif /* (DISABLE_WDOG) */
;;;119    #ifdef CLOCK_SETUP
;;;120      if((RCM->SRS0 & RCM_SRS0_WAKEUP_MASK) != 0x00U)
000006  4842              LDR      r0,|L2.272|
000008  7800              LDRB     r0,[r0,#0]
00000a  07c0              LSLS     r0,r0,#31
00000c  0fc0              LSRS     r0,r0,#31
00000e  2800              CMP      r0,#0
000010  d00a              BEQ      |L2.40|
;;;121      {
;;;122        if((PMC->REGSC & PMC_REGSC_ACKISO_MASK) != 0x00U)
000012  4840              LDR      r0,|L2.276|
000014  7880              LDRB     r0,[r0,#2]
000016  2108              MOVS     r1,#8
000018  4008              ANDS     r0,r0,r1
00001a  2800              CMP      r0,#0
00001c  d004              BEQ      |L2.40|
;;;123        {
;;;124           PMC->REGSC |= PMC_REGSC_ACKISO_MASK; /* Release hold with ACKISO:  Only has an effect if recovering from VLLSx.*/
00001e  483d              LDR      r0,|L2.276|
000020  7880              LDRB     r0,[r0,#2]
000022  4308              ORRS     r0,r0,r1
000024  493b              LDR      r1,|L2.276|
000026  7088              STRB     r0,[r1,#2]
                  |L2.40|
;;;125        }
;;;126      }
;;;127    
;;;128      /* Power mode protection initialization */
;;;129    #ifdef SYSTEM_SMC_PMPROT_VALUE
;;;130      SMC->PMPROT = SYSTEM_SMC_PMPROT_VALUE;
000028  202a              MOVS     r0,#0x2a
00002a  493b              LDR      r1,|L2.280|
00002c  7008              STRB     r0,[r1,#0]
;;;131    #endif
;;;132    
;;;133      /* System clock initialization */
;;;134      /* Internal reference clock trim initialization */
;;;135    #if defined(SLOW_TRIM_ADDRESS)
;;;136      if ( *((uint8_t*)SLOW_TRIM_ADDRESS) != 0xFFU) {                              /* Skip if non-volatile flash memory is erased */
;;;137        MCG->C3 = *((uint8_t*)SLOW_TRIM_ADDRESS);
;;;138      #endif /* defined(SLOW_TRIM_ADDRESS) */
;;;139      #if defined(SLOW_FINE_TRIM_ADDRESS)
;;;140        MCG->C4 = (MCG->C4 & ~(MCG_C4_SCFTRIM_MASK)) | ((*((uint8_t*) SLOW_FINE_TRIM_ADDRESS)) & MCG_C4_SCFTRIM_MASK);
;;;141      #endif
;;;142      #if defined(FAST_TRIM_ADDRESS)
;;;143        MCG->C4 = (MCG->C4 & ~(MCG_C4_FCTRIM_MASK)) |((*((uint8_t*) FAST_TRIM_ADDRESS)) & MCG_C4_FCTRIM_MASK);
;;;144      #endif
;;;145    #if defined(SLOW_TRIM_ADDRESS)
;;;146      }
;;;147      #endif /* defined(SLOW_TRIM_ADDRESS) */
;;;148    
;;;149      /* Set system prescalers and clock sources */
;;;150      SIM->CLKDIV1 = SYSTEM_SIM_CLKDIV1_VALUE; /* Set system prescalers */
00002e  483b              LDR      r0,|L2.284|
000030  4936              LDR      r1,|L2.268|
000032  39c0              SUBS     r1,r1,#0xc0
000034  6048              STR      r0,[r1,#4]
;;;151      SIM->SOPT1 = ((SIM->SOPT1) & (uint32_t)(~(SIM_SOPT1_OSC32KSEL_MASK))) | ((SYSTEM_SIM_SOPT1_VALUE) & (SIM_SOPT1_OSC32KSEL_MASK)); /* Set 32 kHz clock source (ERCLK32K) */
000036  483a              LDR      r0,|L2.288|
000038  6800              LDR      r0,[r0,#0]
00003a  2103              MOVS     r1,#3
00003c  0489              LSLS     r1,r1,#18
00003e  4388              BICS     r0,r0,r1
000040  1840              ADDS     r0,r0,r1
000042  4937              LDR      r1,|L2.288|
000044  6008              STR      r0,[r1,#0]
;;;152      SIM->SOPT2 = ((SIM->SOPT2) & (uint32_t)(~(SIM_SOPT2_PLLFLLSEL_MASK))) | ((SYSTEM_SIM_SOPT2_VALUE) & (SIM_SOPT2_PLLFLLSEL_MASK)); /* Selects the high frequency clock for various peripheral clocking options. */
000046  4837              LDR      r0,|L2.292|
000048  6840              LDR      r0,[r0,#4]
00004a  2101              MOVS     r1,#1
00004c  0409              LSLS     r1,r1,#16
00004e  4388              BICS     r0,r0,r1
000050  1840              ADDS     r0,r0,r1
000052  4934              LDR      r1,|L2.292|
000054  6048              STR      r0,[r1,#4]
;;;153      SIM->SOPT2 = ((SIM->SOPT2) & (uint32_t)(~(SIM_SOPT2_TPMSRC_MASK))) | ((SYSTEM_SIM_SOPT2_VALUE) & (SIM_SOPT2_TPMSRC_MASK)); /* Selects the clock source for the TPM counter clock. */
000056  4608              MOV      r0,r1
000058  6840              LDR      r0,[r0,#4]
00005a  2103              MOVS     r1,#3
00005c  0609              LSLS     r1,r1,#24
00005e  4388              BICS     r0,r0,r1
000060  2101              MOVS     r1,#1
000062  0609              LSLS     r1,r1,#24
000064  1840              ADDS     r0,r0,r1
000066  492f              LDR      r1,|L2.292|
000068  6048              STR      r0,[r1,#4]
;;;154    #if ((MCG_MODE == MCG_MODE_FEI) || (MCG_MODE == MCG_MODE_FBI) || (MCG_MODE == MCG_MODE_BLPI))
;;;155      /* Set MCG and OSC */
;;;156    #if  ((((SYSTEM_OSC0_CR_VALUE) & OSC_CR_ERCLKEN_MASK) != 0x00U) || (((SYSTEM_MCG_C5_VALUE) & MCG_C5_PLLCLKEN0_MASK) != 0x00U))
;;;157      /* SIM_SCGC5: PORTA=1 */
;;;158      SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
;;;159      /* PORTA_PCR18: ISF=0,MUX=0 */
;;;160      PORTA_PCR18 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
;;;161      if (((SYSTEM_MCG_C2_VALUE) & MCG_C2_EREFS0_MASK) != 0x00U) {
;;;162      /* PORTA_PCR19: ISF=0,MUX=0 */
;;;163      PORTA_PCR19 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
;;;164      }
;;;165    #endif
;;;166      MCG->SC = SYSTEM_MCG_SC_VALUE;       /* Set SC (fast clock internal reference divider) */
;;;167      MCG->C1 = SYSTEM_MCG_C1_VALUE;       /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
;;;168      /* Check that the source of the FLL reference clock is the requested one. */
;;;169      if (((SYSTEM_MCG_C1_VALUE) & MCG_C1_IREFS_MASK) != 0x00U) {
;;;170        while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) {
;;;171        }
;;;172      } else {
;;;173        while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) {
;;;174        }
;;;175      }
;;;176      MCG->C2 = (SYSTEM_MCG_C2_VALUE) & (uint8_t)(~(MCG_C2_LP_MASK)); /* Set C2 (freq. range, ext. and int. reference selection etc.; low power bit is set later) */
;;;177      MCG->C4 = ((SYSTEM_MCG_C4_VALUE) & (uint8_t)(~(MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK))) | (MCG->C4 & (MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK)); /* Set C4 (FLL output; trim values not changed) */
;;;178      OSC0->CR = SYSTEM_OSC0_CR_VALUE;     /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
;;;179      #if (MCG_MODE == MCG_MODE_BLPI)
;;;180      /* BLPI specific */
;;;181      MCG->C2 |= (MCG_C2_LP_MASK);         /* Disable FLL and PLL in bypass mode */
;;;182      #endif
;;;183    
;;;184    #else /* MCG_MODE */
;;;185      /* Set MCG and OSC */
;;;186      /* SIM_SCGC5: PORTA=1 */
;;;187      SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
00006a  4608              MOV      r0,r1
00006c  6b80              LDR      r0,[r0,#0x38]
00006e  1549              ASRS     r1,r1,#21
000070  4308              ORRS     r0,r0,r1
000072  492c              LDR      r1,|L2.292|
000074  6388              STR      r0,[r1,#0x38]
;;;188      /* PORTA_PCR18: ISF=0,MUX=0 */
;;;189      PORTA_PCR18 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
000076  482c              LDR      r0,|L2.296|
000078  6880              LDR      r0,[r0,#8]
00007a  492c              LDR      r1,|L2.300|
00007c  4008              ANDS     r0,r0,r1
00007e  492a              LDR      r1,|L2.296|
000080  6088              STR      r0,[r1,#8]
;;;190      if (((SYSTEM_MCG_C2_VALUE) & MCG_C2_EREFS0_MASK) != 0x00U) {
;;;191      /* PORTA_PCR19: ISF=0,MUX=0 */
;;;192      PORTA_PCR19 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
000082  4608              MOV      r0,r1
000084  68c0              LDR      r0,[r0,#0xc]
000086  4929              LDR      r1,|L2.300|
000088  4008              ANDS     r0,r0,r1
00008a  4927              LDR      r1,|L2.296|
00008c  60c8              STR      r0,[r1,#0xc]
;;;193      }
;;;194      MCG->SC = SYSTEM_MCG_SC_VALUE;       /* Set SC (fast clock internal reference divider) */
00008e  2000              MOVS     r0,#0
000090  4927              LDR      r1,|L2.304|
000092  7208              STRB     r0,[r1,#8]
;;;195      MCG->C2 = (SYSTEM_MCG_C2_VALUE) & (uint8_t)(~(MCG_C2_LP_MASK)); /* Set C2 (freq. range, ext. and int. reference selection etc.; low power bit is set later) */
000094  2024              MOVS     r0,#0x24
000096  7048              STRB     r0,[r1,#1]
;;;196      OSC0->CR = SYSTEM_OSC0_CR_VALUE;     /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
000098  2080              MOVS     r0,#0x80
00009a  4926              LDR      r1,|L2.308|
00009c  7008              STRB     r0,[r1,#0]
;;;197      #if (MCG_MODE == MCG_MODE_PEE)
;;;198      MCG->C1 = (SYSTEM_MCG_C1_VALUE) | MCG_C1_CLKS(0x02); /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) - PBE mode*/
00009e  209a              MOVS     r0,#0x9a
0000a0  4923              LDR      r1,|L2.304|
0000a2  7008              STRB     r0,[r1,#0]
;;;199      #else
;;;200      MCG->C1 = SYSTEM_MCG_C1_VALUE;       /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
;;;201      #endif
;;;202      if (((SYSTEM_MCG_C2_VALUE) & MCG_C2_EREFS0_MASK) != 0x00U) {
;;;203        while((MCG->S & MCG_S_OSCINIT0_MASK) == 0x00U) { /* Check that the oscillator is running */
0000a4  bf00              NOP      
                  |L2.166|
0000a6  4822              LDR      r0,|L2.304|
0000a8  7980              LDRB     r0,[r0,#6]
0000aa  2102              MOVS     r1,#2
0000ac  4008              ANDS     r0,r0,r1
0000ae  2800              CMP      r0,#0
0000b0  d0f9              BEQ      |L2.166|
;;;204        }
;;;205      }
;;;206      /* Check that the source of the FLL reference clock is the requested one. */
;;;207      if (((SYSTEM_MCG_C1_VALUE) & MCG_C1_IREFS_MASK) != 0x00U) {
;;;208        while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) {
;;;209        }
;;;210      } else {
;;;211        while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) {
0000b2  bf00              NOP      
                  |L2.180|
0000b4  481e              LDR      r0,|L2.304|
0000b6  7980              LDRB     r0,[r0,#6]
0000b8  2110              MOVS     r1,#0x10
0000ba  4008              ANDS     r0,r0,r1
0000bc  2800              CMP      r0,#0
0000be  d1f9              BNE      |L2.180|
;;;212        }
;;;213      }
;;;214      MCG->C4 = ((SYSTEM_MCG_C4_VALUE)  & (uint8_t)(~(MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK))) | (MCG->C4 & (MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK)); /* Set C4 (FLL output; trim values not changed) */
0000c0  481b              LDR      r0,|L2.304|
0000c2  78c0              LDRB     r0,[r0,#3]
0000c4  06c0              LSLS     r0,r0,#27
0000c6  0ec0              LSRS     r0,r0,#27
0000c8  4919              LDR      r1,|L2.304|
0000ca  70c8              STRB     r0,[r1,#3]
;;;215    #endif /* MCG_MODE */
;;;216    
;;;217      /* Common for all MCG modes */
;;;218    
;;;219      /* PLL clock can be used to generate clock for some devices regardless of clock generator (MCGOUTCLK) mode. */
;;;220      MCG->C5 = (SYSTEM_MCG_C5_VALUE) & (uint8_t)(~(MCG_C5_PLLCLKEN0_MASK)); /* Set C5 (PLL settings, PLL reference divider etc.) */
0000cc  2001              MOVS     r0,#1
0000ce  7108              STRB     r0,[r1,#4]
;;;221      MCG->C6 = (SYSTEM_MCG_C6_VALUE) & (uint8_t)~(MCG_C6_PLLS_MASK); /* Set C6 (PLL select, VCO divider etc.) */
0000d0  2000              MOVS     r0,#0
0000d2  7148              STRB     r0,[r1,#5]
;;;222      if ((SYSTEM_MCG_C5_VALUE) & MCG_C5_PLLCLKEN0_MASK) {
;;;223        MCG->C5 |= MCG_C5_PLLCLKEN0_MASK;  /* PLL clock enable in mode other than PEE or PBE */
;;;224      }
;;;225      /* BLPE, PEE and PBE MCG mode specific */
;;;226    
;;;227    #if (MCG_MODE == MCG_MODE_BLPE)
;;;228      MCG->C2 |= (MCG_C2_LP_MASK);         /* Disable FLL and PLL in bypass mode */
;;;229    #elif ((MCG_MODE == MCG_MODE_PBE) || (MCG_MODE == MCG_MODE_PEE))
;;;230      MCG->C6 |= (MCG_C6_PLLS_MASK);       /* Set C6 (PLL select, VCO divider etc.) */
0000d4  4608              MOV      r0,r1
0000d6  7940              LDRB     r0,[r0,#5]
0000d8  2140              MOVS     r1,#0x40
0000da  4308              ORRS     r0,r0,r1
0000dc  4914              LDR      r1,|L2.304|
0000de  7148              STRB     r0,[r1,#5]
;;;231      while((MCG->S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until PLL is locked*/
0000e0  bf00              NOP      
                  |L2.226|
0000e2  4813              LDR      r0,|L2.304|
0000e4  7980              LDRB     r0,[r0,#6]
0000e6  2140              MOVS     r1,#0x40
0000e8  4008              ANDS     r0,r0,r1
0000ea  2800              CMP      r0,#0
0000ec  d0f9              BEQ      |L2.226|
;;;232      }
;;;233      #if (MCG_MODE == MCG_MODE_PEE)
;;;234      MCG->C1 &= (uint8_t)~(MCG_C1_CLKS_MASK);
0000ee  4810              LDR      r0,|L2.304|
0000f0  7800              LDRB     r0,[r0,#0]
0000f2  0680              LSLS     r0,r0,#26
0000f4  0e80              LSRS     r0,r0,#26
0000f6  490e              LDR      r1,|L2.304|
0000f8  7008              STRB     r0,[r1,#0]
;;;235      #endif
;;;236    #endif
;;;237    #if ((MCG_MODE == MCG_MODE_FEI) || (MCG_MODE == MCG_MODE_FEE))
;;;238      while((MCG->S & MCG_S_CLKST_MASK) != 0x00U) { /* Wait until output of the FLL is selected */
;;;239      }
;;;240      /* Use LPTMR to wait for 1ms for FLL clock stabilization */
;;;241      SIM_SCGC5 |= SIM_SCGC5_LPTMR_MASK;   /* Alow software control of LPMTR */
;;;242      LPTMR0->CMR = LPTMR_CMR_COMPARE(0);  /* Default 1 LPO tick */
;;;243      LPTMR0->CSR = (LPTMR_CSR_TCF_MASK | LPTMR_CSR_TPS(0x00));
;;;244      LPTMR0->PSR = (LPTMR_PSR_PCS(0x01) | LPTMR_PSR_PBYP_MASK); /* Clock source: LPO, Prescaler bypass enable */
;;;245      LPTMR0->CSR = LPTMR_CSR_TEN_MASK;    /* LPMTR enable */
;;;246      while((LPTMR0_CSR & LPTMR_CSR_TCF_MASK) == 0u) {
;;;247      }
;;;248      LPTMR0_CSR = 0x00;                   /* Disable LPTMR */
;;;249      SIM_SCGC5 &= (uint32_t)~(uint32_t)SIM_SCGC5_LPTMR_MASK;
;;;250    #elif ((MCG_MODE == MCG_MODE_FBI) || (MCG_MODE == MCG_MODE_BLPI))
;;;251      while((MCG->S & MCG_S_CLKST_MASK) != 0x04U) { /* Wait until internal reference clock is selected as MCG output */
;;;252      }
;;;253    #elif ((MCG_MODE == MCG_MODE_FBE) || (MCG_MODE == MCG_MODE_PBE) || (MCG_MODE == MCG_MODE_BLPE))
;;;254      while((MCG->S & MCG_S_CLKST_MASK) != 0x08U) { /* Wait until external reference clock is selected as MCG output */
;;;255      }
;;;256    #elif (MCG_MODE == MCG_MODE_PEE)
;;;257      while((MCG->S & MCG_S_CLKST_MASK) != 0x0CU) { /* Wait until output of the PLL is selected */
0000fa  bf00              NOP      
                  |L2.252|
0000fc  480c              LDR      r0,|L2.304|
0000fe  7980              LDRB     r0,[r0,#6]
000100  210c              MOVS     r1,#0xc
000102  4008              ANDS     r0,r0,r1
000104  280c              CMP      r0,#0xc
000106  d1f9              BNE      |L2.252|
;;;258      }
;;;259    #endif
;;;260    #if (((SYSTEM_SMC_PMCTRL_VALUE) & SMC_PMCTRL_RUNM_MASK) == (0x02U << SMC_PMCTRL_RUNM_SHIFT))
;;;261      SMC->PMCTRL = (uint8_t)((SYSTEM_SMC_PMCTRL_VALUE) & (SMC_PMCTRL_RUNM_MASK)); /* Enable VLPR mode */
;;;262      while(SMC->PMSTAT != 0x04U) {        /* Wait until the system is in VLPR mode */
;;;263      }
;;;264    #endif
;;;265    
;;;266      /* PLL loss of lock interrupt request initialization */
;;;267      if (((SYSTEM_MCG_C6_VALUE) & MCG_C6_LOLIE0_MASK) != 0U) {
;;;268        NVIC_EnableIRQ(MCG_IRQn);          /* Enable PLL loss of lock interrupt request */
;;;269      }
;;;270    #endif
;;;271    }
000108  4770              BX       lr
;;;272    
                          ENDP

00010a  0000              DCW      0x0000
                  |L2.268|
                          DCD      0x40048100
                  |L2.272|
                          DCD      0x4007f000
                  |L2.276|
                          DCD      0x4007d000
                  |L2.280|
                          DCD      0x4007e000
                  |L2.284|
                          DCD      0x10010000
                  |L2.288|
                          DCD      0x40047000
                  |L2.292|
                          DCD      0x40048000
                  |L2.296|
                          DCD      0x40049040
                  |L2.300|
                          DCD      0xfefff8ff
                  |L2.304|
                          DCD      0x40064000
                  |L2.308|
                          DCD      0x40065000

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x02dc6c00

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L22.24|
                  |L22.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L22.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L22.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "RTE\\Device\\MKL25Z128xxx4\\system_MKL25Z4.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_system_MKL25Z4_c_5d646a67____REV16|
#line 383 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.0-Beta4\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_system_MKL25Z4_c_5d646a67____REV16| PROC
#line 384

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_system_MKL25Z4_c_5d646a67____REVSH|
#line 397
|__asm___16_system_MKL25Z4_c_5d646a67____REVSH| PROC
#line 398

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
