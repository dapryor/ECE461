; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\uart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\uart.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I.\inc -I"C:\Users\Alex\Documents\Teaching\ECE492 - ESA\Code\git\ESA\MCU_Intro_UV5\Serial-Demo\RTE" -I"C:\Users\Alex\Documents\Teaching\ECE492 - ESA\Code\git\ESA\MCU_Intro_UV5\Serial-Demo\RTE\Device\MKL25Z128xxx4" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0-Beta4\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.12.0\Device\Include -D__UVISION_VERSION=517 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\uart.crf src\UART.c]
                          THUMB

                          AREA ||i.Get_Rx_Char||, CODE, READONLY, ALIGN=2

                  Get_Rx_Char PROC
;;;329    
;;;330    uint8_t	Get_Rx_Char(void) {
000000  b510              PUSH     {r4,lr}
;;;331    	return Q_Dequeue(&RxQ);
000002  4802              LDR      r0,|L1.12|
000004  f7fffffe          BL       Q_Dequeue
;;;332    }
000008  bd10              POP      {r4,pc}
;;;333    
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      ||RxQ||

                          AREA ||i.Init_UART0||, CODE, READONLY, ALIGN=2

                  Init_UART0 PROC
;;;66     
;;;67     void Init_UART0(uint32_t baud_rate) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  4604              MOV      r4,r0
;;;68     	uint16_t sbr;
;;;69     	uint8_t temp;
;;;70     	
;;;71     	// Enable clock gating for UART0 and Port A
;;;72     	SIM->SCGC4 |= SIM_SCGC4_UART0_MASK; 										
000004  483e              LDR      r0,|L2.256|
000006  6b40              LDR      r0,[r0,#0x34]
000008  2101              MOVS     r1,#1
00000a  0289              LSLS     r1,r1,#10
00000c  4308              ORRS     r0,r0,r1
00000e  493c              LDR      r1,|L2.256|
000010  6348              STR      r0,[r1,#0x34]
;;;73     	SIM->SCGC5 |= SIM_SCGC5_PORTA_MASK;											
000012  4608              MOV      r0,r1
000014  6b80              LDR      r0,[r0,#0x38]
000016  1549              ASRS     r1,r1,#21
000018  4308              ORRS     r0,r0,r1
00001a  4939              LDR      r1,|L2.256|
00001c  6388              STR      r0,[r1,#0x38]
;;;74     	
;;;75     	// Make sure transmitter and receiver are disabled before init
;;;76     	UART0->C2 &= ~UART0_C2_TE_MASK & ~UART0_C2_RE_MASK; 		
00001e  4839              LDR      r0,|L2.260|
000020  78c0              LDRB     r0,[r0,#3]
000022  210c              MOVS     r1,#0xc
000024  4388              BICS     r0,r0,r1
000026  4937              LDR      r1,|L2.260|
000028  70c8              STRB     r0,[r1,#3]
;;;77     	
;;;78     	// Set UART clock to 48 MHz clock 
;;;79     	SIM->SOPT2 |= SIM_SOPT2_UART0SRC(1);
00002a  4835              LDR      r0,|L2.256|
00002c  6840              LDR      r0,[r0,#4]
00002e  2101              MOVS     r1,#1
000030  0689              LSLS     r1,r1,#26
000032  4308              ORRS     r0,r0,r1
000034  4932              LDR      r1,|L2.256|
000036  6048              STR      r0,[r1,#4]
;;;80     	SIM->SOPT2 |= SIM_SOPT2_PLLFLLSEL_MASK;
000038  4608              MOV      r0,r1
00003a  6840              LDR      r0,[r0,#4]
00003c  2101              MOVS     r1,#1
00003e  0409              LSLS     r1,r1,#16
000040  4308              ORRS     r0,r0,r1
000042  492f              LDR      r1,|L2.256|
000044  6048              STR      r0,[r1,#4]
;;;81     
;;;82     	// Set pins to UART0 Rx and Tx
;;;83     	PORTA->PCR[1] = PORT_PCR_ISF_MASK | PORT_PCR_MUX(2); // Rx
000046  4830              LDR      r0,|L2.264|
000048  4930              LDR      r1,|L2.268|
00004a  6048              STR      r0,[r1,#4]
;;;84     	PORTA->PCR[2] = PORT_PCR_ISF_MASK | PORT_PCR_MUX(2); // Tx
00004c  6088              STR      r0,[r1,#8]
;;;85     	
;;;86     	// Set baud rate and oversampling ratio
;;;87     	sbr = (uint16_t)((SYS_CLOCK)/(baud_rate * UART_OVERSAMPLE_RATE)); 			
00004e  0120              LSLS     r0,r4,#4
000050  f7fffffe          BL       __aeabi_ui2d
000054  4605              MOV      r5,r0
000056  462a              MOV      r2,r5
000058  460b              MOV      r3,r1
00005a  2000              MOVS     r0,#0
00005c  492c              LDR      r1,|L2.272|
00005e  f7fffffe          BL       __aeabi_ddiv
000062  9101              STR      r1,[sp,#4]
000064  9000              STR      r0,[sp,#0]
000066  f7fffffe          BL       __aeabi_d2uiz
00006a  b287              UXTH     r7,r0
;;;88     	UART0->BDH &= ~UART0_BDH_SBR_MASK;
00006c  4825              LDR      r0,|L2.260|
00006e  7800              LDRB     r0,[r0,#0]
000070  0940              LSRS     r0,r0,#5
000072  0140              LSLS     r0,r0,#5
000074  4923              LDR      r1,|L2.260|
000076  7008              STRB     r0,[r1,#0]
;;;89     	UART0->BDH |= UART0_BDH_SBR(sbr>>8);
000078  4608              MOV      r0,r1
00007a  7800              LDRB     r0,[r0,#0]
00007c  04f9              LSLS     r1,r7,#19
00007e  0ec9              LSRS     r1,r1,#27
000080  4308              ORRS     r0,r0,r1
000082  4920              LDR      r1,|L2.260|
000084  7008              STRB     r0,[r1,#0]
;;;90     	UART0->BDL = UART0_BDL_SBR(sbr);
000086  704f              STRB     r7,[r1,#1]
;;;91     	UART0->C4 |= UART0_C4_OSR(UART_OVERSAMPLE_RATE-1);				
000088  4608              MOV      r0,r1
00008a  7a80              LDRB     r0,[r0,#0xa]
00008c  210f              MOVS     r1,#0xf
00008e  4308              ORRS     r0,r0,r1
000090  491c              LDR      r1,|L2.260|
000092  7288              STRB     r0,[r1,#0xa]
;;;92     
;;;93     	// Disable interrupts for RX active edge and LIN break detect, select one stop bit
;;;94     	UART0->BDH |= UART0_BDH_RXEDGIE(0) | UART0_BDH_SBNS(0) | UART0_BDH_LBKDIE(0);
000094  4608              MOV      r0,r1
000096  7800              LDRB     r0,[r0,#0]
000098  7008              STRB     r0,[r1,#0]
;;;95     	
;;;96     	// Don't enable loopback mode, use 8 data bit mode, don't use parity
;;;97     	UART0->C1 = UART0_C1_LOOPS(0) | UART0_C1_M(0) | UART0_C1_PE(0); 
00009a  2000              MOVS     r0,#0
00009c  7088              STRB     r0,[r1,#2]
;;;98     	// Don't invert transmit data, don't enable interrupts for errors
;;;99     	UART0->C3 = UART0_C3_TXINV(0) | UART0_C3_ORIE(0)| UART0_C3_NEIE(0) 
00009e  7188              STRB     r0,[r1,#6]
;;;100    			| UART0_C3_FEIE(0) | UART0_C3_PEIE(0);
;;;101    
;;;102    	// Clear error flags
;;;103    	UART0->S1 = UART0_S1_OR(1) | UART0_S1_NF(1) | UART0_S1_FE(1) | UART0_S1_PF(1);
0000a0  200f              MOVS     r0,#0xf
0000a2  7108              STRB     r0,[r1,#4]
;;;104    
;;;105    	// Try it a different way
;;;106    	UART0->S1 |= UART0_S1_OR_MASK | UART0_S1_NF_MASK | 
0000a4  4608              MOV      r0,r1
0000a6  7900              LDRB     r0,[r0,#4]
0000a8  210f              MOVS     r1,#0xf
0000aa  4308              ORRS     r0,r0,r1
0000ac  4915              LDR      r1,|L2.260|
0000ae  7108              STRB     r0,[r1,#4]
;;;107    									UART0_S1_FE_MASK | UART0_S1_PF_MASK;
;;;108    	
;;;109    	// Send LSB first, do not invert received data
;;;110    	UART0->S2 = UART0_S2_MSBF(0) | UART0_S2_RXINV(0); 
0000b0  2000              MOVS     r0,#0
0000b2  7148              STRB     r0,[r1,#5]
;;;111    
;;;112    	
;;;113    // Enable interrupts
;;;114    #if USE_UART_INTERRUPTS
;;;115    	Q_Init(&TxQ);
0000b4  4817              LDR      r0,|L2.276|
0000b6  f7fffffe          BL       Q_Init
;;;116    	Q_Init(&RxQ);
0000ba  4817              LDR      r0,|L2.280|
0000bc  f7fffffe          BL       Q_Init
;;;117    
;;;118    	NVIC_SetPriority(UART0_IRQn, 2); // 0, 1, 2, or 3
0000c0  2102              MOVS     r1,#2
0000c2  200c              MOVS     r0,#0xc
0000c4  f7fffffe          BL       NVIC_SetPriority
;;;119    	NVIC_ClearPendingIRQ(UART0_IRQn); 
0000c8  200c              MOVS     r0,#0xc
0000ca  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;120    	NVIC_EnableIRQ(UART0_IRQn);
0000ce  200c              MOVS     r0,#0xc
0000d0  f7fffffe          BL       NVIC_EnableIRQ
;;;121    
;;;122    	// Enable receive interrupts but not transmit interrupts yet
;;;123    	UART0->C2 |= UART_C2_RIE(1);
0000d4  480b              LDR      r0,|L2.260|
0000d6  78c0              LDRB     r0,[r0,#3]
0000d8  2120              MOVS     r1,#0x20
0000da  4308              ORRS     r0,r0,r1
0000dc  4909              LDR      r1,|L2.260|
0000de  70c8              STRB     r0,[r1,#3]
;;;124    #endif
;;;125    
;;;126    	// Enable UART receiver and transmitter
;;;127    	UART0->C2 |= UART0_C2_RE(1) | UART0_C2_TE(1);	
0000e0  4608              MOV      r0,r1
0000e2  78c0              LDRB     r0,[r0,#3]
0000e4  210c              MOVS     r1,#0xc
0000e6  4308              ORRS     r0,r0,r1
0000e8  4906              LDR      r1,|L2.260|
0000ea  70c8              STRB     r0,[r1,#3]
;;;128    	
;;;129    	// Clear the UART RDRF flag
;;;130    	temp = UART0->D;
0000ec  4608              MOV      r0,r1
0000ee  79c0              LDRB     r0,[r0,#7]
0000f0  9002              STR      r0,[sp,#8]
;;;131    	UART0->S1 &= ~UART0_S1_RDRF_MASK;
0000f2  4608              MOV      r0,r1
0000f4  7900              LDRB     r0,[r0,#4]
0000f6  2120              MOVS     r1,#0x20
0000f8  4388              BICS     r0,r0,r1
0000fa  4902              LDR      r1,|L2.260|
0000fc  7108              STRB     r0,[r1,#4]
;;;132    
;;;133    }
0000fe  bdfe              POP      {r1-r7,pc}
;;;134    
                          ENDP

                  |L2.256|
                          DCD      0x40048000
                  |L2.260|
                          DCD      0x4006a000
                  |L2.264|
                          DCD      0x01000200
                  |L2.268|
                          DCD      0x40049000
                  |L2.272|
                          DCD      0x4186e360
                  |L2.276|
                          DCD      TxQ
                  |L2.280|
                          DCD      ||RxQ||

                          AREA ||i.Init_UART2||, CODE, READONLY, ALIGN=2

                  Init_UART2 PROC
;;;229    
;;;230    void Init_UART2(uint32_t baud_rate) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  4604              MOV      r4,r0
;;;231    	uint32_t divisor;
;;;232    	
;;;233    	// enable clock to UART and Port E
;;;234    	SIM->SCGC4 |= SIM_SCGC4_UART2_MASK;
000004  4824              LDR      r0,|L3.152|
000006  6b40              LDR      r0,[r0,#0x34]
000008  2101              MOVS     r1,#1
00000a  0309              LSLS     r1,r1,#12
00000c  4308              ORRS     r0,r0,r1
00000e  4922              LDR      r1,|L3.152|
000010  6348              STR      r0,[r1,#0x34]
;;;235    	SIM->SCGC5 |= SIM_SCGC5_PORTE_MASK;
000012  4608              MOV      r0,r1
000014  6b80              LDR      r0,[r0,#0x38]
000016  2101              MOVS     r1,#1
000018  0349              LSLS     r1,r1,#13
00001a  4308              ORRS     r0,r0,r1
00001c  491e              LDR      r1,|L3.152|
00001e  6388              STR      r0,[r1,#0x38]
;;;236    
;;;237    
;;;238    	// select UART pins
;;;239    	PORTE->PCR[22] = PORT_PCR_MUX(4); // Tx
000020  1508              ASRS     r0,r1,#20
000022  491e              LDR      r1,|L3.156|
000024  6188              STR      r0,[r1,#0x18]
;;;240    	PORTE->PCR[23] = PORT_PCR_MUX(4); // Rx
000026  61c8              STR      r0,[r1,#0x1c]
;;;241    	
;;;242    	UART2->C2 &=  ~(UARTLP_C2_TE_MASK | UARTLP_C2_RE_MASK);
000028  481d              LDR      r0,|L3.160|
00002a  78c0              LDRB     r0,[r0,#3]
00002c  210c              MOVS     r1,#0xc
00002e  4388              BICS     r0,r0,r1
000030  491b              LDR      r1,|L3.160|
000032  70c8              STRB     r0,[r1,#3]
;;;243    		
;;;244    	// Set baud rate to 4800 baud
;;;245    	divisor = BUS_CLOCK/(baud_rate*16);
000034  0120              LSLS     r0,r4,#4
000036  f7fffffe          BL       __aeabi_ui2d
00003a  4605              MOV      r5,r0
00003c  462a              MOV      r2,r5
00003e  460b              MOV      r3,r1
000040  2000              MOVS     r0,#0
000042  4918              LDR      r1,|L3.164|
000044  f7fffffe          BL       __aeabi_ddiv
000048  9101              STR      r1,[sp,#4]
00004a  9000              STR      r0,[sp,#0]
00004c  f7fffffe          BL       __aeabi_d2uiz
000050  4607              MOV      r7,r0
;;;246    	UART2->BDH = UART_BDH_SBR(divisor>>8);
000052  04f8              LSLS     r0,r7,#19
000054  0ec0              LSRS     r0,r0,#27
000056  4912              LDR      r1,|L3.160|
000058  7008              STRB     r0,[r1,#0]
;;;247    	UART2->BDL = UART_BDL_SBR(divisor);
00005a  704f              STRB     r7,[r1,#1]
;;;248    	
;;;249    	// No parity, 8 bits, two stop bits, other settings;
;;;250    	UART2->C1 = 0; 
00005c  2000              MOVS     r0,#0
00005e  7088              STRB     r0,[r1,#2]
;;;251    	UART2->S2 = 0;
000060  7148              STRB     r0,[r1,#5]
;;;252    	UART2->C3 = 0;
000062  7188              STRB     r0,[r1,#6]
;;;253    	
;;;254    // Enable transmitter and receiver but not interrupts
;;;255    	UART2->C2 = UART_C2_TE_MASK | UART_C2_RE_MASK;
000064  200c              MOVS     r0,#0xc
000066  70c8              STRB     r0,[r1,#3]
;;;256    	
;;;257    #if USE_UART_INTERRUPTS
;;;258    	NVIC_SetPriority(UART2_IRQn, 2); // 0, 1, 2, or 3
000068  2102              MOVS     r1,#2
00006a  200e              MOVS     r0,#0xe
00006c  f7fffffe          BL       NVIC_SetPriority
;;;259    	NVIC_ClearPendingIRQ(UART2_IRQn); 
000070  200e              MOVS     r0,#0xe
000072  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;260    	NVIC_EnableIRQ(UART2_IRQn);
000076  200e              MOVS     r0,#0xe
000078  f7fffffe          BL       NVIC_EnableIRQ
;;;261    
;;;262    	UART2->C2 |= UART_C2_RIE_MASK;
00007c  4808              LDR      r0,|L3.160|
00007e  78c0              LDRB     r0,[r0,#3]
000080  2120              MOVS     r1,#0x20
000082  4308              ORRS     r0,r0,r1
000084  4906              LDR      r1,|L3.160|
000086  70c8              STRB     r0,[r1,#3]
;;;263    	Q_Init(&TxQ);
000088  4807              LDR      r0,|L3.168|
00008a  f7fffffe          BL       Q_Init
;;;264    	Q_Init(&RxQ);
00008e  4807              LDR      r0,|L3.172|
000090  f7fffffe          BL       Q_Init
;;;265    #endif
;;;266    
;;;267    }
000094  bdfe              POP      {r1-r7,pc}
;;;268    
                          ENDP

000096  0000              DCW      0x0000
                  |L3.152|
                          DCD      0x40048000
                  |L3.156|
                          DCD      0x4004d040
                  |L3.160|
                          DCD      0x4006c000
                  |L3.164|
                          DCD      0x4176e360
                  |L3.168|
                          DCD      TxQ
                  |L3.172|
                          DCD      ||RxQ||

                          AREA ||i.NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_ClearPendingIRQ PROC
;;;846     */
;;;847    __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;848    {
;;;849      if ((int32_t)(IRQn) >= 0)
000002  db05              BLT      |L4.16|
;;;850      {
;;;851        NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  06c2              LSLS     r2,r0,#27
000006  0ed2              LSRS     r2,r2,#27
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  4a01              LDR      r2,|L4.20|
00000e  6011              STR      r1,[r2,#0]
                  |L4.16|
;;;852      }
;;;853    }
000010  4770              BX       lr
;;;854    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0xe000e280

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_EnableIRQ PROC
;;;780     */
;;;781    __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;782    {
;;;783      if ((int32_t)(IRQn) >= 0)
000002  db05              BLT      |L5.16|
;;;784      {
;;;785        NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  06c2              LSLS     r2,r0,#27
000006  0ed2              LSRS     r2,r2,#27
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  4a01              LDR      r2,|L5.20|
00000e  6011              STR      r1,[r2,#0]
                  |L5.16|
;;;786      }
;;;787    }
000010  4770              BX       lr
;;;788    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0xe000e100

                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;864     */
;;;865    __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;866    {
;;;867      if ((int32_t)(IRQn) >= 0)
000002  2800              CMP      r0,#0
000004  db19              BLT      |L6.58|
;;;868      {
;;;869        NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
000006  4a1a              LDR      r2,|L6.112|
000008  2303              MOVS     r3,#3
00000a  021b              LSLS     r3,r3,#8
00000c  18d2              ADDS     r2,r2,r3
00000e  0883              LSRS     r3,r0,#2
000010  009b              LSLS     r3,r3,#2
000012  58d2              LDR      r2,[r2,r3]
000014  0783              LSLS     r3,r0,#30
000016  0edc              LSRS     r4,r3,#27
000018  23ff              MOVS     r3,#0xff
00001a  40a3              LSLS     r3,r3,r4
00001c  439a              BICS     r2,r2,r3
00001e  078b              LSLS     r3,r1,#30
000020  0e1b              LSRS     r3,r3,#24
000022  0784              LSLS     r4,r0,#30
000024  0ee4              LSRS     r4,r4,#27
000026  40a3              LSLS     r3,r3,r4
000028  431a              ORRS     r2,r2,r3
00002a  4b11              LDR      r3,|L6.112|
00002c  2403              MOVS     r4,#3
00002e  0224              LSLS     r4,r4,#8
000030  191b              ADDS     r3,r3,r4
000032  0884              LSRS     r4,r0,#2
000034  00a4              LSLS     r4,r4,#2
000036  511a              STR      r2,[r3,r4]
000038  e018              B        |L6.108|
                  |L6.58|
;;;870           (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
;;;871      }
;;;872      else
;;;873      {
;;;874        SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
00003a  4a0e              LDR      r2,|L6.116|
00003c  0703              LSLS     r3,r0,#28
00003e  0f1b              LSRS     r3,r3,#28
000040  3b08              SUBS     r3,r3,#8
000042  089b              LSRS     r3,r3,#2
000044  009b              LSLS     r3,r3,#2
000046  58d2              LDR      r2,[r2,r3]
000048  0783              LSLS     r3,r0,#30
00004a  0edc              LSRS     r4,r3,#27
00004c  23ff              MOVS     r3,#0xff
00004e  40a3              LSLS     r3,r3,r4
000050  439a              BICS     r2,r2,r3
000052  078b              LSLS     r3,r1,#30
000054  0e1b              LSRS     r3,r3,#24
000056  0784              LSLS     r4,r0,#30
000058  0ee4              LSRS     r4,r4,#27
00005a  40a3              LSLS     r3,r3,r4
00005c  431a              ORRS     r2,r2,r3
00005e  4b05              LDR      r3,|L6.116|
000060  0704              LSLS     r4,r0,#28
000062  0f24              LSRS     r4,r4,#28
000064  3c08              SUBS     r4,r4,#8
000066  08a4              LSRS     r4,r4,#2
000068  00a4              LSLS     r4,r4,#2
00006a  511a              STR      r2,[r3,r4]
                  |L6.108|
;;;875           (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
;;;876      }
;;;877    }
00006c  bd10              POP      {r4,pc}
;;;878    
                          ENDP

00006e  0000              DCW      0x0000
                  |L6.112|
                          DCD      0xe000e100
                  |L6.116|
                          DCD      0xe000ed1c

                          AREA ||i.Rx_Chars_Available||, CODE, READONLY, ALIGN=2

                  Rx_Chars_Available PROC
;;;325    
;;;326    uint32_t Rx_Chars_Available(void) {
000000  b510              PUSH     {r4,lr}
;;;327    	return Q_Size(&RxQ);
000002  4802              LDR      r0,|L7.12|
000004  f7fffffe          BL       Q_Size
;;;328    }
000008  bd10              POP      {r4,pc}
;;;329    
                          ENDP

00000a  0000              DCW      0x0000
                  |L7.12|
                          DCD      ||RxQ||

                          AREA ||i.Send_String||, CODE, READONLY, ALIGN=2

                  Send_String PROC
;;;207    
;;;208    void Send_String(uint8_t * str) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;209    	// enqueue string
;;;210    	while (*str != '\0') { // copy characters up to null terminator
000004  e00a              B        |L8.28|
                  |L8.6|
;;;211    		while (Q_Full(&TxQ))
000006  bf00              NOP      
                  |L8.8|
000008  480f              LDR      r0,|L8.72|
00000a  f7fffffe          BL       Q_Full
00000e  2800              CMP      r0,#0
000010  d1fa              BNE      |L8.8|
;;;212    			; // wait for space to open up
;;;213    		Q_Enqueue(&TxQ, *str);
000012  7821              LDRB     r1,[r4,#0]
000014  480c              LDR      r0,|L8.72|
000016  f7fffffe          BL       Q_Enqueue
;;;214    		str++;
00001a  1c64              ADDS     r4,r4,#1
                  |L8.28|
00001c  7820              LDRB     r0,[r4,#0]            ;210
00001e  2800              CMP      r0,#0                 ;210
000020  d1f1              BNE      |L8.6|
;;;215    	}
;;;216    	// start transmitter if it isn't already running
;;;217    #if QUEUED_U0
;;;218    	if (!(UART0->C2 & UART0_C2_TIE_MASK)) {
000022  480a              LDR      r0,|L8.76|
000024  78c0              LDRB     r0,[r0,#3]
000026  2180              MOVS     r1,#0x80
000028  4008              ANDS     r0,r0,r1
00002a  2800              CMP      r0,#0
00002c  d10a              BNE      |L8.68|
;;;219    		UART0->D = Q_Dequeue(&TxQ); 
00002e  4806              LDR      r0,|L8.72|
000030  f7fffffe          BL       Q_Dequeue
000034  4905              LDR      r1,|L8.76|
000036  71c8              STRB     r0,[r1,#7]
;;;220    		UART0->C2 |= UART0_C2_TIE(1);
000038  4608              MOV      r0,r1
00003a  78c0              LDRB     r0,[r0,#3]
00003c  2180              MOVS     r1,#0x80
00003e  4308              ORRS     r0,r0,r1
000040  4902              LDR      r1,|L8.76|
000042  70c8              STRB     r0,[r1,#3]
                  |L8.68|
;;;221    	}
;;;222    #elif QUEUED_U2
;;;223    	if (!(UART2->C2 & UART_C2_TIE_MASK)) {
;;;224    		UART2->D = Q_Dequeue(&TxQ); 
;;;225    		UART2->C2 |= UART_C2_TIE(1);
;;;226    	}
;;;227    #endif
;;;228    }
000044  bd10              POP      {r4,pc}
;;;229    
                          ENDP

000046  0000              DCW      0x0000
                  |L8.72|
                          DCD      TxQ
                  |L8.76|
                          DCD      0x4006a000

                          AREA ||i.UART0_Echo_Interrupt_Test||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  UART0_Echo_Interrupt_Test PROC
;;;178    // UART0 Interrupt Echo
;;;179    void UART0_Echo_Interrupt_Test(void) {	
000000  b094              SUB      sp,sp,#0x50
;;;180    	uint8_t buffer[80], c, * bp;
;;;181    	
;;;182    	// Read first character and discard it
;;;183    	// c = Q_Dequeue(&RxQ);
;;;184    	
;;;185    	while (1) {
000002  e029              B        |L9.88|
                  |L9.4|
;;;186    			// Blocking receove
;;;187    			while (Q_Size(&RxQ) == 0)
000004  bf00              NOP      
                  |L9.6|
000006  4815              LDR      r0,|L9.92|
000008  f7fffffe          BL       Q_Size
00000c  2800              CMP      r0,#0
00000e  d0fa              BEQ      |L9.6|
;;;188    				;
;;;189    			c = Q_Dequeue(&RxQ);
000010  4812              LDR      r0,|L9.92|
000012  f7fffffe          BL       Q_Dequeue
000016  4605              MOV      r5,r0
;;;190    			
;;;191    			// Blocking transmit
;;;192    			sprintf((char *) buffer, "You pressed %c\n\r", c);
000018  462a              MOV      r2,r5
00001a  a111              ADR      r1,|L9.96|
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       __2sprintf
;;;193    			// enqueue string
;;;194    			bp = buffer;
000022  466c              MOV      r4,sp
;;;195    			while (*bp != '\0') { // copy characters up to null terminator
000024  e00a              B        |L9.60|
                  |L9.38|
;;;196    				while (Q_Full(&TxQ))
000026  bf00              NOP      
                  |L9.40|
000028  4812              LDR      r0,|L9.116|
00002a  f7fffffe          BL       Q_Full
00002e  2800              CMP      r0,#0
000030  d1fa              BNE      |L9.40|
;;;197    					; // wait for space to open up
;;;198    				Q_Enqueue(&TxQ, *bp);
000032  7821              LDRB     r1,[r4,#0]
000034  480f              LDR      r0,|L9.116|
000036  f7fffffe          BL       Q_Enqueue
;;;199    				bp++;
00003a  1c64              ADDS     r4,r4,#1
                  |L9.60|
00003c  7820              LDRB     r0,[r4,#0]            ;195
00003e  2800              CMP      r0,#0                 ;195
000040  d1f1              BNE      |L9.38|
;;;200    			}
;;;201    			// start transmitter if it isn't already running
;;;202    			if (!(UART0->C2 & UART0_C2_TIE_MASK)) {
000042  480d              LDR      r0,|L9.120|
000044  78c0              LDRB     r0,[r0,#3]
000046  2180              MOVS     r1,#0x80
000048  4008              ANDS     r0,r0,r1
00004a  2800              CMP      r0,#0
00004c  d104              BNE      |L9.88|
;;;203    				UART0->C2 |= UART0_C2_TIE(1);
00004e  480a              LDR      r0,|L9.120|
000050  78c0              LDRB     r0,[r0,#3]
000052  4308              ORRS     r0,r0,r1
000054  4908              LDR      r1,|L9.120|
000056  70c8              STRB     r0,[r1,#3]
                  |L9.88|
000058  e7d4              B        |L9.4|
;;;204    			}
;;;205    	}
;;;206    }
;;;207    
                          ENDP

00005a  0000              DCW      0x0000
                  |L9.92|
                          DCD      ||RxQ||
                  |L9.96|
000060  596f7520          DCB      "You pressed %c\n\r",0
000064  70726573
000068  73656420
00006c  25630a0d
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L9.116|
                          DCD      TxQ
                  |L9.120|
                          DCD      0x4006a000

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;144    
;;;145    void UART0_IRQHandler(void) {
000000  b510              PUSH     {r4,lr}
;;;146    	uint8_t ch;
;;;147    	
;;;148    	if (UART0->S1 & (UART_S1_OR_MASK |UART_S1_NF_MASK | 
000002  481e              LDR      r0,|L10.124|
000004  7900              LDRB     r0,[r0,#4]
000006  0700              LSLS     r0,r0,#28
000008  0f00              LSRS     r0,r0,#28
00000a  2800              CMP      r0,#0
00000c  d007              BEQ      |L10.30|
;;;149    		UART_S1_FE_MASK | UART_S1_PF_MASK)) {
;;;150    			// clear the error flags
;;;151    			UART0->S1 |= UART0_S1_OR_MASK | UART0_S1_NF_MASK | 
00000e  481b              LDR      r0,|L10.124|
000010  7900              LDRB     r0,[r0,#4]
000012  210f              MOVS     r1,#0xf
000014  4308              ORRS     r0,r0,r1
000016  4919              LDR      r1,|L10.124|
000018  7108              STRB     r0,[r1,#4]
;;;152    									UART0_S1_FE_MASK | UART0_S1_PF_MASK;	
;;;153    			// read the data register to clear RDRF
;;;154    			ch = UART0->D;
00001a  4608              MOV      r0,r1
00001c  79c4              LDRB     r4,[r0,#7]
                  |L10.30|
;;;155    	}
;;;156    	if (UART0->S1 & UART0_S1_RDRF_MASK) {
00001e  4817              LDR      r0,|L10.124|
000020  7900              LDRB     r0,[r0,#4]
000022  2120              MOVS     r1,#0x20
000024  4008              ANDS     r0,r0,r1
000026  2800              CMP      r0,#0
000028  d00a              BEQ      |L10.64|
;;;157    		// received a character
;;;158    		ch = UART0->D;
00002a  4814              LDR      r0,|L10.124|
00002c  79c4              LDRB     r4,[r0,#7]
;;;159    		if (!Q_Full(&RxQ)) {
00002e  4814              LDR      r0,|L10.128|
000030  f7fffffe          BL       Q_Full
000034  2800              CMP      r0,#0
000036  d103              BNE      |L10.64|
;;;160    			Q_Enqueue(&RxQ, ch);
000038  4621              MOV      r1,r4
00003a  4811              LDR      r0,|L10.128|
00003c  f7fffffe          BL       Q_Enqueue
                  |L10.64|
;;;161    		} else {
;;;162    			// error - queue full.
;;;163    			// discard character
;;;164    		}
;;;165    	}
;;;166    	if ( (UART0->C2 & UART0_C2_TIE_MASK) && // transmitter interrupt enabled
000040  480e              LDR      r0,|L10.124|
000042  78c0              LDRB     r0,[r0,#3]
000044  2180              MOVS     r1,#0x80
000046  4008              ANDS     r0,r0,r1
000048  2800              CMP      r0,#0
00004a  d015              BEQ      |L10.120|
;;;167    			(UART0->S1 & UART0_S1_TDRE_MASK) ) { // tx buffer empty
00004c  480b              LDR      r0,|L10.124|
00004e  7900              LDRB     r0,[r0,#4]
000050  4008              ANDS     r0,r0,r1
000052  2800              CMP      r0,#0
000054  d010              BEQ      |L10.120|
;;;168    		// can send another character
;;;169    		if (!Q_Empty(&TxQ)) {
000056  480b              LDR      r0,|L10.132|
000058  f7fffffe          BL       Q_Empty
00005c  2800              CMP      r0,#0
00005e  d105              BNE      |L10.108|
;;;170    			UART0->D = Q_Dequeue(&TxQ);
000060  4808              LDR      r0,|L10.132|
000062  f7fffffe          BL       Q_Dequeue
000066  4905              LDR      r1,|L10.124|
000068  71c8              STRB     r0,[r1,#7]
00006a  e005              B        |L10.120|
                  |L10.108|
;;;171    		} else {
;;;172    			// queue is empty so disable transmitter interrupt
;;;173    			UART0->C2 &= ~UART0_C2_TIE_MASK;
00006c  4803              LDR      r0,|L10.124|
00006e  78c0              LDRB     r0,[r0,#3]
000070  2180              MOVS     r1,#0x80
000072  4388              BICS     r0,r0,r1
000074  4901              LDR      r1,|L10.124|
000076  70c8              STRB     r0,[r1,#3]
                  |L10.120|
;;;174    		}
;;;175    	}
;;;176    }
000078  bd10              POP      {r4,pc}
;;;177    
                          ENDP

00007a  0000              DCW      0x0000
                  |L10.124|
                          DCD      0x4006a000
                  |L10.128|
                          DCD      ||RxQ||
                  |L10.132|
                          DCD      TxQ

                          AREA ||i.UART0_Receive_Poll||, CODE, READONLY, ALIGN=2

                  UART0_Receive_Poll PROC
;;;274    
;;;275    uint8_t UART0_Receive_Poll(void) {
000000  bf00              NOP      
                  |L11.2|
;;;276    		while (!(UART0->S1 & UART0_S1_RDRF_MASK))
000002  4804              LDR      r0,|L11.20|
000004  7900              LDRB     r0,[r0,#4]
000006  2120              MOVS     r1,#0x20
000008  4008              ANDS     r0,r0,r1
00000a  2800              CMP      r0,#0
00000c  d0f9              BEQ      |L11.2|
;;;277    			;
;;;278    		return UART0->D;
00000e  4801              LDR      r0,|L11.20|
000010  79c0              LDRB     r0,[r0,#7]
;;;279    }	
000012  4770              BX       lr
;;;280    
                          ENDP

                  |L11.20|
                          DCD      0x4006a000

                          AREA ||i.UART0_Transmit_Poll||, CODE, READONLY, ALIGN=2

                  UART0_Transmit_Poll PROC
;;;268    
;;;269    void UART0_Transmit_Poll(uint8_t data) {
000000  bf00              NOP      
                  |L12.2|
;;;270    		while (!(UART0->S1 & UART0_S1_TDRE_MASK))
000002  4904              LDR      r1,|L12.20|
000004  7909              LDRB     r1,[r1,#4]
000006  2280              MOVS     r2,#0x80
000008  4011              ANDS     r1,r1,r2
00000a  2900              CMP      r1,#0
00000c  d0f9              BEQ      |L12.2|
;;;271    			;
;;;272    		UART0->D = data;
00000e  4901              LDR      r1,|L12.20|
000010  71c8              STRB     r0,[r1,#7]
;;;273    }	
000012  4770              BX       lr
;;;274    
                          ENDP

                  |L12.20|
                          DCD      0x4006a000

                          AREA ||i.UART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART2_IRQHandler PROC
;;;292    
;;;293    void UART2_IRQHandler(void) {
000000  b510              PUSH     {r4,lr}
;;;294    	uint8_t ch;
;;;295    
;;;296    	if (UART2->S1 & (UART_S1_OR_MASK |UART_S1_NF_MASK | 
000002  481c              LDR      r0,|L13.116|
000004  7900              LDRB     r0,[r0,#4]
000006  0700              LSLS     r0,r0,#28
000008  0f00              LSRS     r0,r0,#28
00000a  2800              CMP      r0,#0
00000c  d001              BEQ      |L13.18|
;;;297    		UART_S1_FE_MASK | UART_S1_PF_MASK)) {
;;;298    			// handle the error
;;;299    			// clear the flag
;;;300    			// UART2->S1 |= UART_S1_OR_MASK | UART_S1_NF_MASK | UART_S1_FE_MASK | UART_S1_PF_MASK;
;;;301    			ch = UART2->D;
00000e  4819              LDR      r0,|L13.116|
000010  79c4              LDRB     r4,[r0,#7]
                  |L13.18|
;;;302    		}
;;;303    	if (UART2->S1 & UART_S1_RDRF_MASK) {
000012  4818              LDR      r0,|L13.116|
000014  7900              LDRB     r0,[r0,#4]
000016  2120              MOVS     r1,#0x20
000018  4008              ANDS     r0,r0,r1
00001a  2800              CMP      r0,#0
00001c  d00c              BEQ      |L13.56|
;;;304    		// received a character
;;;305    		if (!Q_Full(&RxQ)) {
00001e  4816              LDR      r0,|L13.120|
000020  f7fffffe          BL       Q_Full
000024  2800              CMP      r0,#0
000026  d105              BNE      |L13.52|
;;;306    			Q_Enqueue(&RxQ, UART2->D);
000028  4812              LDR      r0,|L13.116|
00002a  79c1              LDRB     r1,[r0,#7]
00002c  4812              LDR      r0,|L13.120|
00002e  f7fffffe          BL       Q_Enqueue
000032  e001              B        |L13.56|
                  |L13.52|
;;;307    		} else {
;;;308    			// error - queue full.
;;;309    			while (1)
000034  bf00              NOP      
                  |L13.54|
000036  e7fe              B        |L13.54|
                  |L13.56|
;;;310    				;
;;;311    		}
;;;312    	}	
;;;313    	if ( (UART2->C2 & UART_C2_TIE_MASK) && // transmitter interrupt enabled
000038  480e              LDR      r0,|L13.116|
00003a  78c0              LDRB     r0,[r0,#3]
00003c  2180              MOVS     r1,#0x80
00003e  4008              ANDS     r0,r0,r1
000040  2800              CMP      r0,#0
000042  d015              BEQ      |L13.112|
;;;314    			(UART2->S1 & UART_S1_TDRE_MASK) ) { // tx buffer empty
000044  480b              LDR      r0,|L13.116|
000046  7900              LDRB     r0,[r0,#4]
000048  4008              ANDS     r0,r0,r1
00004a  2800              CMP      r0,#0
00004c  d010              BEQ      |L13.112|
;;;315    		// can send another character
;;;316    		if (!Q_Empty(&TxQ)) {
00004e  480b              LDR      r0,|L13.124|
000050  f7fffffe          BL       Q_Empty
000054  2800              CMP      r0,#0
000056  d105              BNE      |L13.100|
;;;317    			UART2->D = Q_Dequeue(&TxQ);
000058  4808              LDR      r0,|L13.124|
00005a  f7fffffe          BL       Q_Dequeue
00005e  4905              LDR      r1,|L13.116|
000060  71c8              STRB     r0,[r1,#7]
000062  e005              B        |L13.112|
                  |L13.100|
;;;318    		} else {
;;;319    			// queue is empty so disable transmitter interrupt
;;;320    			UART2->C2 &= ~UART_C2_TIE_MASK;
000064  4803              LDR      r0,|L13.116|
000066  78c0              LDRB     r0,[r0,#3]
000068  2180              MOVS     r1,#0x80
00006a  4388              BICS     r0,r0,r1
00006c  4901              LDR      r1,|L13.116|
00006e  70c8              STRB     r0,[r1,#3]
                  |L13.112|
;;;321    		}
;;;322    	}
;;;323    
;;;324    }
000070  bd10              POP      {r4,pc}
;;;325    
                          ENDP

000072  0000              DCW      0x0000
                  |L13.116|
                          DCD      0x4006c000
                  |L13.120|
                          DCD      ||RxQ||
                  |L13.124|
                          DCD      TxQ

                          AREA ||i.UART2_Receive_Poll||, CODE, READONLY, ALIGN=2

                  UART2_Receive_Poll PROC
;;;286    
;;;287    uint8_t UART2_Receive_Poll(void) {
000000  bf00              NOP      
                  |L14.2|
;;;288    		while (!(UART2->S1 & UART_S1_RDRF_MASK))
000002  4804              LDR      r0,|L14.20|
000004  7900              LDRB     r0,[r0,#4]
000006  2120              MOVS     r1,#0x20
000008  4008              ANDS     r0,r0,r1
00000a  2800              CMP      r0,#0
00000c  d0f9              BEQ      |L14.2|
;;;289    			;
;;;290    		return UART2->D;
00000e  4801              LDR      r0,|L14.20|
000010  79c0              LDRB     r0,[r0,#7]
;;;291    }	
000012  4770              BX       lr
;;;292    
                          ENDP

                  |L14.20|
                          DCD      0x4006c000

                          AREA ||i.UART2_Transmit_Poll||, CODE, READONLY, ALIGN=2

                  UART2_Transmit_Poll PROC
;;;280    
;;;281    void UART2_Transmit_Poll(uint8_t data) {
000000  bf00              NOP      
                  |L15.2|
;;;282    		while (!(UART2->S1 & UART_S1_TDRE_MASK))
000002  4904              LDR      r1,|L15.20|
000004  7909              LDRB     r1,[r1,#4]
000006  2280              MOVS     r2,#0x80
000008  4011              ANDS     r1,r1,r2
00000a  2900              CMP      r1,#0
00000c  d0f9              BEQ      |L15.2|
;;;283    			;
;;;284    		UART2->D = data;
00000e  4901              LDR      r1,|L15.20|
000010  71c8              STRB     r0,[r1,#7]
;;;285    }	
000012  4770              BX       lr
;;;286    
                          ENDP

                  |L15.20|
                          DCD      0x4006c000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  TxQ
                          %        268
                  ||RxQ||
                          %        268

;*** Start embedded assembler ***

#line 1 "src\\UART.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_UART_c_7bb2c661____REV16|
#line 383 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.0-Beta4\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_UART_c_7bb2c661____REV16| PROC
#line 384

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_UART_c_7bb2c661____REVSH|
#line 397
|__asm___6_UART_c_7bb2c661____REVSH| PROC
#line 398

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
