; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\queue.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\queue.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I.\inc -I"C:\Users\Alex\Documents\Teaching\ECE492 - ESA\Code\git\ESA\MCU_Intro_UV5\Serial-Demo\RTE" -I"C:\Users\Alex\Documents\Teaching\ECE492 - ESA\Code\git\ESA\MCU_Intro_UV5\Serial-Demo\RTE\Device\MKL25Z128xxx4" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0-Beta4\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.12.0\Device\Include -D__UVISION_VERSION=517 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\queue.crf src\queue.c]
                          THUMB

                          AREA ||i.Q_Dequeue||, CODE, READONLY, ALIGN=1

                  Q_Dequeue PROC
;;;45     
;;;46     uint8_t Q_Dequeue(Q_T * q) {
000000  b530              PUSH     {r4,r5,lr}
000002  4602              MOV      r2,r0
;;;47     	uint32_t masking_state;
;;;48       uint8_t t=0;
000004  2400              MOVS     r4,#0
;;;49       // Check to see if queue is empty before dequeueing
;;;50       if (!Q_Empty(q)) {
000006  4610              MOV      r0,r2
000008  f7fffffe          BL       Q_Empty
00000c  2800              CMP      r0,#0
00000e  d11b              BNE      |L1.72|
;;;51         t = q->Data[q->Head];
000010  6811              LDR      r1,[r2,#0]
000012  4610              MOV      r0,r2
000014  300c              ADDS     r0,r0,#0xc
000016  5c44              LDRB     r4,[r0,r1]
;;;52         q->Data[q->Head++] = '_'; // empty unused entries for debugging
000018  215f              MOVS     r1,#0x5f
00001a  6810              LDR      r0,[r2,#0]
00001c  1c45              ADDS     r5,r0,#1
00001e  6015              STR      r5,[r2,#0]
000020  4615              MOV      r5,r2
000022  350c              ADDS     r5,r5,#0xc
000024  5429              STRB     r1,[r5,r0]
;;;53     		q->Head %= Q_MAX_SIZE;
000026  6810              LDR      r0,[r2,#0]
000028  b2c0              UXTB     r0,r0
00002a  6010              STR      r0,[r2,#0]
;;;54     
;;;55     		// protect q->Size-- operation from preemption
;;;56     		// save current masking state
;;;57     		masking_state = __get_PRIMASK();
00002c  bf00              NOP      
00002e  f3ef8010          MRS      r0,PRIMASK
000032  4603              MOV      r3,r0
000034  bf00              NOP      
;;;58     		// disable interrupts
;;;59     		__disable_irq();
000036  b672              CPSID    i
;;;60     		// update variable
;;;61         q->Size--;
000038  6890              LDR      r0,[r2,#8]
00003a  1e40              SUBS     r0,r0,#1
00003c  6090              STR      r0,[r2,#8]
;;;62     		// restore  interrupt masking state
;;;63     		__set_PRIMASK(masking_state);
00003e  bf00              NOP      
000040  f3838810          MSR      PRIMASK,r3
000044  bf00              NOP      
000046  bf00              NOP      
                  |L1.72|
;;;64       }
;;;65       return t;
000048  4620              MOV      r0,r4
;;;66     }
00004a  bd30              POP      {r4,r5,pc}
;;;67     
                          ENDP


                          AREA ||i.Q_Empty||, CODE, READONLY, ALIGN=1

                  Q_Empty PROC
;;;11     
;;;12     int Q_Empty(Q_T * q) {
000000  4601              MOV      r1,r0
;;;13       return q->Size == 0;
000002  6888              LDR      r0,[r1,#8]
000004  2800              CMP      r0,#0
000006  d101              BNE      |L2.12|
000008  2001              MOVS     r0,#1
                  |L2.10|
;;;14     }
00000a  4770              BX       lr
                  |L2.12|
00000c  2000              MOVS     r0,#0                 ;13
00000e  e7fc              B        |L2.10|
;;;15     
                          ENDP


                          AREA ||i.Q_Enqueue||, CODE, READONLY, ALIGN=1

                  Q_Enqueue PROC
;;;23     
;;;24     int Q_Enqueue(Q_T * q, uint8_t d) {
000000  b530              PUSH     {r4,r5,lr}
000002  4603              MOV      r3,r0
000004  460d              MOV      r5,r1
;;;25     	uint32_t masking_state;
;;;26       // If queue is full, don't overwrite data, but do return an error code
;;;27       if (!Q_Full(q)) {
000006  4618              MOV      r0,r3
000008  f7fffffe          BL       Q_Full
00000c  2800              CMP      r0,#0
00000e  d117              BNE      |L3.64|
;;;28         q->Data[q->Tail++] = d;
000010  6858              LDR      r0,[r3,#4]
000012  1c41              ADDS     r1,r0,#1
000014  6059              STR      r1,[r3,#4]
000016  4619              MOV      r1,r3
000018  310c              ADDS     r1,r1,#0xc
00001a  540d              STRB     r5,[r1,r0]
;;;29         q->Tail %= Q_MAX_SIZE;
00001c  6858              LDR      r0,[r3,#4]
00001e  b2c0              UXTB     r0,r0
000020  6058              STR      r0,[r3,#4]
;;;30     		
;;;31     		// protect q->Size++ operation from preemption
;;;32     		// save current masking state
;;;33     		masking_state = __get_PRIMASK();
000022  bf00              NOP      
000024  f3ef8010          MRS      r0,PRIMASK
000028  4604              MOV      r4,r0
00002a  bf00              NOP      
;;;34     		// disable interrupts
;;;35     		__disable_irq();
00002c  b672              CPSID    i
;;;36     		// update variable
;;;37         q->Size++;
00002e  6898              LDR      r0,[r3,#8]
000030  1c40              ADDS     r0,r0,#1
000032  6098              STR      r0,[r3,#8]
;;;38     		// restore  interrupt masking state
;;;39     		__set_PRIMASK(masking_state);
000034  bf00              NOP      
000036  f3848810          MSR      PRIMASK,r4
00003a  bf00              NOP      
;;;40     		
;;;41         return 1; // success
00003c  2001              MOVS     r0,#1
                  |L3.62|
;;;42       } else 
;;;43         return 0; // failure
;;;44     }
00003e  bd30              POP      {r4,r5,pc}
                  |L3.64|
000040  2000              MOVS     r0,#0                 ;43
000042  e7fc              B        |L3.62|
;;;45     
                          ENDP


                          AREA ||i.Q_Full||, CODE, READONLY, ALIGN=1

                  Q_Full PROC
;;;15     
;;;16     int Q_Full(Q_T * q) {
000000  4601              MOV      r1,r0
;;;17       return q->Size == Q_MAX_SIZE;
000002  6888              LDR      r0,[r1,#8]
000004  22ff              MOVS     r2,#0xff
000006  3201              ADDS     r2,#1
000008  4290              CMP      r0,r2
00000a  d101              BNE      |L4.16|
00000c  2001              MOVS     r0,#1
                  |L4.14|
;;;18     }
00000e  4770              BX       lr
                  |L4.16|
000010  2000              MOVS     r0,#0                 ;17
000012  e7fc              B        |L4.14|
;;;19     
                          ENDP


                          AREA ||i.Q_Init||, CODE, READONLY, ALIGN=1

                  Q_Init PROC
;;;2      
;;;3      void Q_Init(Q_T * q) {
000000  2100              MOVS     r1,#0
;;;4        unsigned int i;
;;;5        for (i=0; i<Q_MAX_SIZE; i++)  
000002  e004              B        |L5.14|
                  |L5.4|
;;;6          q->Data[i] = '_';  // to simplify our lives when debugging
000004  235f              MOVS     r3,#0x5f
000006  4602              MOV      r2,r0
000008  320c              ADDS     r2,r2,#0xc
00000a  5453              STRB     r3,[r2,r1]
00000c  1c49              ADDS     r1,r1,#1              ;5
                  |L5.14|
00000e  29ff              CMP      r1,#0xff              ;5
000010  d9f8              BLS      |L5.4|
;;;7        q->Head = 0;
000012  2200              MOVS     r2,#0
000014  6002              STR      r2,[r0,#0]
;;;8        q->Tail = 0;
000016  6042              STR      r2,[r0,#4]
;;;9        q->Size = 0;
000018  6082              STR      r2,[r0,#8]
;;;10     }
00001a  4770              BX       lr
;;;11     
                          ENDP


                          AREA ||i.Q_Size||, CODE, READONLY, ALIGN=1

                  Q_Size PROC
;;;19     
;;;20     int Q_Size(Q_T * q) {
000000  4601              MOV      r1,r0
;;;21     	return q->Size;
000002  6888              LDR      r0,[r1,#8]
;;;22     }
000004  4770              BX       lr
;;;23     
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\queue.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_queue_c_Q_Init____REV16|
#line 383 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.0-Beta4\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_queue_c_Q_Init____REV16| PROC
#line 384

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_queue_c_Q_Init____REVSH|
#line 397
|__asm___7_queue_c_Q_Init____REVSH| PROC
#line 398

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
